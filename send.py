# GPIOピン制御・PWM制御のライブラリを読み込む
from machine import Pin, PWM

# 時間関連のライブラリを読み込む
import time

# PWM制御を行うピンの設定
ir = PWM(Pin(17, Pin.OUT))

# PWM制御の動作周波数を設定
# 一般的なリモコンで使用されている周波数 = 38KHz
f = 38000
ir.freq(f)

# PWM制御の周期（波が上下に1回振動するのにかかる時間）
# 周期 = 1/周波数（38kHz）= 26μs

# PWMのデューティー比（HIGHとLOWの比率）
# 一般的なリモコンのデューティー比 = HIGH：1/3、LOW：2/3
# 16bitの最大値 = FFFF（16進数）= 65535(10進数）
# 65535 * 0.3333 = 21845(10進数）= 5555（16進数）
dty = 0x5555

# 解析したデータが信号を一つ送るのに掛かっていた時間 = 300us
# 300usの長さの信号になるようにPWM信号を繰り返す
# 300us/26us = 11.5回
# しかしtime.ticksで赤外線通信の稼働時間を計測した結果、
# 理想のフレーム長（53ms～55ms）に足りない
# よって稼働時間が53ms以上になるように「20」と調整した
adj = 35

# 上位8bitは共通コード（11100010）
# 下位8bitは操作ボタン（01000000 = 電源ON/OFF
# 照度up     data =[0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, / 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1]
# 照度down   data = [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1]
# 順送り　    data = [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1]
# 30分off    data = [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1]
# 60分off    data = [0,  0,  0,  0,  0,  0,  0,  1,  0,  1,  1,  1,  0,  1,  1,  0,  0,  1,  0,  0,  0,  0,  0,  0,  1,  0,  1,  1,  1,  1,  1,  1]
# タイマー解除 data = [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1]
# 消灯       data = [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]


# 赤外線通信の稼働時間を計測開始
start = time.ticks_us()

#　はじめのやつ
# デューティー比1/3がHIGHのPWM信号を送信（adj回分）
for i in range(1, 18*adj):
    ir.duty_u16(dty)
            
# LOWのPWM信号を送信（3×adj回分）
for i in range(1, 9*adj):
    ir.duty_u16(0)

# 16bitのコードを読み込む
for bit in data:
       
    # コードの値が「1」のときの処理
    if(bit == 1):
        
        # デューティー比1/3がHIGHのPWM信号を送信（adj回分）
        for i in range(1, 1*adj):
            ir.duty_u16(dty)
            
        # LOWのPWM信号を送信（3×adj回分）
        for i in range(1, 3*adj):
            ir.duty_u16(0)
         
    # コードの値が「0」のときの処理
    else:
        
        # デューティー比1/3がHIGHのPWM信号を送信（adj回分）
        for i in range(1, 1*adj):
            ir.duty_u16(dty)
            
        # LOWのPWM信号を送信（7×adj回分）
        for i in range(1, 1*adj):
                ir.duty_u16(0)
    
# ストップビット（データの終端を示す信号）
for l in range(1,1*adj):
    ir.duty_u16(dty)

# トレーラー（通信の終わりを示す信号）
for l in range(1,1*adj):
    for i in range(1,85):
        ir.duty_u16(0)
              
# 赤外線通信の稼働時間を出力（53000us以上になっていればOK）
print(time.ticks_diff(time.ticks_us(), start))
